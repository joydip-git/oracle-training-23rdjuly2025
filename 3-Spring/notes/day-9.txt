Spring
Hibernate (OR/M tool)
RESTful services:
	Web Service (JAX-WS)
	REST Service (JAX-RS)
	SpringBoot (framework/tool)
	Helidon (Oracle's own product to create RESTful service)


Dependency Injection:
---------------------------
App class depends on DataManager instance
DataManager depends on DbDataReader instance

these are the dependencies in our application
currently our code is very "tightly-coupled", since we are creating instance of a "depndency" (DbDataReader, DataManager) in the "dependent" (DataManager, App)
	- change in the name of class will affect every dependent
	- change in architecture will affect every depdendent
	etc.

goal is to make our code "loosely-coupled"
	- rely on abstraction rather than concrete implementation

Dependency Injection/Inversion: If any class is dependent on another class (dependency), creating instance of the dependency (DataReader type - FileDataReader or DbDataReader) and supplying it to the instance of dependent (DataManager) via constructor, method or setter.
Interface is the abstraction we need, rather a concrete implementation.

a. in case of DI of some class (Dependency) instance into other class (Dependent) instance, the dependency (DbDataReader/FileDataReader) MUST implement an interface (expose their functionality via an interface as contract)

b. the dependent class (DataManager) must declare/have a data member of type abstract type (abstract class/interface - DataReader). should NOT have any data member of actual classes (concrete class/implementation - FileDataReader/DbDataReader).

c. the dependent class (DataManager) must provide a parameterized constructor with an argument of type abstract type (abstract class/interface - DataReader) for DI through constructor.

supply the instance of the dependency (DataReader type) instance to the instance of dependent party (DataManager) via constructor while creating the instance of dependent party.
     IB	  IC   ID
A -> B -> C -> D

manual DI resolution:
--------------------------
new A(new B(new C(new D())));

automatic resolution: (IoC - Inversion of Control)
---------------------------
in your app, you need DI framework, and that framework has to resolve dependencies in the app and then create instance of dependencies and supply them to the dependents 
the control of creating instance in your app code is handed over to some framework -> IoC


Spring Framework:
----------------------------
developed by Mr. Rod Johnson in 2003
lightweight framework
framework of frameworks (Struts, hibernate, springboot, EJB, JSF etc.)
provides solution for lots of technical problems that we face while developing our application.

modules
	- testing
	- core container
		- core
		- beans
		- context
		- EL (Expression Language)
	- data access
		- JDBC
		- OR/M (Object Relational Mapping)
		- OXM
		- JMS
		- transaction
	- web
		- servlet
		- web
		- portlet
		- struts


Spring IoC (Inversion of Control) 
------------------------------------
IoC Container -> responsible for 
		a. resolving dependencies
		b. instantiating the dependencies
		c. configure and assemble the objects

Beans Congiration:
------------------------
	a. XML file
	b. annotation (through Java code)

types of IoC Container: (interfaces)
	a. BeanFactory (package - org.springframework.beans.factory)
	b. ApplicationContext (package - org.springframework.context)

Note: ApplicationContext interface (inherits from) is built at the top of BeanFactory interface. It adds some extra functionality on top of functionalities provided by BeanFactory.
	- Spring's AOP (Aspect-oriented programming)
	- application specific IoC 

Perform DI in Java app:
	a. constructor
	b. setter method

Beans in Spring IoC:
--------------------------
certain objects that are managed by Spring
these objects actually helps you manage DI in your app
Through beans, Spring container manages and injects dependencies between differnt "beans".

POJO -> Plain Old Java Object 

Employee instance is dependent on Address instance

Spring IoC container, while creating an instance of an Employee, will figure out that it has a dependency on Address type. So, Spring IoC will create instance of Address and then will supply to Employee instance.


<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd">
</beans>










